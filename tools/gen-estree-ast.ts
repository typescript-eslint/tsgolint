import { Node, CodeBlockWriter, TypeNode, TypeReferenceNode } from 'ts-morph'
import * as fs from 'node:fs'
import * as path from 'node:path'
import { collectConvertableAstNodes, estreePkgPath } from './shared.ts'

const writer = new CodeBlockWriter({ useTabs: true })
writer.writeLine('\n// Code generated by ast-spec-converter.ts. DO NOT EDIT.\n')
writer.writeLine('package estree\n')

function convertTypeReference(typeNode: TypeReferenceNode) {
  if (typeNode.getType().isUnion()) {
    return 'any'
  }

  let text = typeNode.getText()
  if (text.startsWith('VariableDeclarator')) {
    text = 'VariableDeclarator'
  } else if (text === 'StringLiteral') {
    text = 'Literal'
  }
  return '*' + text
}

function convertUnionType(typeNode: TypeNode) {
  if (!Node.isUnionTypeNode(typeNode)) {
    return null
  }

  const unionTypeNodes = typeNode.getTypeNodes()
  const typeRef = unionTypeNodes.find((n) => Node.isTypeReference(n))
  const hasNullable = unionTypeNodes.some((n) =>
    ['null', 'undefined'].includes(n.getText()),
  )

  if (
    unionTypeNodes.length == 2 &&
    typeRef != null &&
    typeRef.getText() !== 'RegExp' &&
    hasNullable
  ) {
    return convertTypeReference(typeRef)
  }

  if (
    unionTypeNodes.every(
      (n) => Node.isLiteralTypeNode(n) && Node.isStringLiteral(n.getLiteral()),
    )
  ) {
    return 'string'
  }

  return null
}

function uncapitalize(s: string): string {
  return s[0].toLowerCase() + s.slice(1)
}

for (const { interfaceName, decl: statement } of collectConvertableAstNodes()) {
  const properties = statement
    .getType()
    .getProperties()
    .map((p) => p.getValueDeclarationOrThrow())
    .filter((p) => Node.isPropertySignature(p))

  writer.writeLine(`type ${interfaceName} struct {`)
  const namesForReflection: string[] = ['SetParent']
  writer.indent(() => {
    for (const property of properties) {
      let name = property.getName()

      let type = 'any'
      const typeNode = property.getTypeNodeOrThrow()
      const propertyType = property.getType()
      const convertedUnion = convertUnionType(typeNode)
      if (name === 'exported' && interfaceName === 'ExportAllDeclaration') {
        // TODO: this is a bug in @typescript-eslint/ast-spec
        // ExportAllDeclaration.exported should allow Literal for the
        // export * as "foo" from "foo"
        type = 'any'
      } else if (convertedUnion != null) {
        type = convertedUnion
      } else if (name === 'type') {
        type = 'ESTreeKind'
      } else if (
        name === 'declarations' &&
        interfaceName === 'VariableDeclaration'
      ) {
        type = '[]any'
      } else if (
        (name === 'tokens' || name === 'comments') &&
        interfaceName === 'Program'
      ) {
        type = '[]NodeWithRange'
      } else if (
        (name === 'assertions' &&
          [
            'ImportDeclaration',
            'ExportAllDeclaration',
            'ExportNamedDeclaration',
          ].includes(interfaceName)) ||
        (name === 'members' && interfaceName === 'TSEnumDeclaration')
      ) {
        // deprecated
        continue
      } else if (
        Node.isLiteralTypeNode(typeNode) &&
        (Node.isFalseLiteral(typeNode.getLiteral()) ||
          Node.isTrueLiteral(typeNode.getLiteral()))
      ) {
        type = 'bool'
      } else if (
        Node.isLiteralTypeNode(typeNode) &&
        Node.isStringLiteral(typeNode.getLiteral())
      ) {
        type = 'string'
      } else if (Node.isExpression(typeNode)) {
        const typeNodeText = typeNode.getText()
        if (typeNodeText === 'string') {
          type = 'string'
        } else if (typeNodeText === 'boolean') {
          type = 'bool'
        }
      } else if (Node.isTypeReference(typeNode)) {
        const text = typeNode.getText()
        if (text.startsWith('ValueOf')) {
          type = 'string'
        } else if (text === 'SourceLocation' || text === 'Range') {
          type = text
        } else {
          type = convertTypeReference(typeNode)
        }
      } else if (Node.isArrayTypeNode(typeNode)) {
        let elementTypeNode = typeNode.getElementTypeNode()
        while (Node.isParenthesizedTypeNode(elementTypeNode)) {
          elementTypeNode = elementTypeNode.getTypeNode()
        }
        const convertedElementUnion = convertUnionType(elementTypeNode)
        if (convertedElementUnion != null) {
          type = '[]' + convertedElementUnion
        } else if (Node.isTypeReference(elementTypeNode)) {
          type = '[]' + convertTypeReference(elementTypeNode)
        } else if (propertyType.isArray()) {
          type = '[]any'
        }
      }
      name = name[0].toUpperCase() + name.slice(1)
      let comment = property.getText()
      if (comment.includes('\n')) {
        comment = `/* ${comment} */`
      } else {
        comment = `// ${comment}`
      }
      namesForReflection.push(name)
      writer.writeLine(`${name} ${type} ${comment}`)
    }

    if (interfaceName !== 'Program') {
      writer.writeLine('Parent NodeWithRange')
      namesForReflection.push('Parent')
    }
  })
  writer.writeLine('}')

  if (interfaceName === 'Program') {
    writer.writeLine(`func (p *Program) SetSourceType(t string) {
	p.SourceType = t
}
`)
    namesForReflection.push('SetSourceType')
  }
  writer.writeLine(`func (d *${interfaceName}) GetType() ESTreeKind {
	return d.Type
}
func (d *${interfaceName}) GetRange() Range {
	return d.Range
}
func (d *${interfaceName}) setRange(r Range) {
	d.Range = r
}
func (d *${interfaceName}) GetLoc() SourceLocation {
	return d.Loc
}
func (d *${interfaceName}) setLoc(l SourceLocation) {
	d.Loc = l
}
func (d *${interfaceName}) SetParent(parent NodeWithRange) {
  ${interfaceName === 'Program' ? '' : 'd.Parent = parent'}
}
func (d *${interfaceName}) JsInterop(prop string) any {
switch prop {
${namesForReflection.map(name => `case "${uncapitalize(name)}":\n\t return d.${name}`).join('\n')}
default:
  return nil
}
}
`)
}

fs.writeFileSync(
  path.join(estreePkgPath, './ast.go'),
  writer.toString(),
  'utf8',
)
