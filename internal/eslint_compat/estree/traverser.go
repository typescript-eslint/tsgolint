// Code generated by gen-traverser.ts. DO NOT EDIT.

package estree

func (t *traverser) traverseInner(node NodeWithRange) {
	switch node.GetType() {
	case ESTreeKindArrayExpression:
		if node.(*ArrayExpression).Elements != nil {
			for _, child := range node.(*ArrayExpression).Elements {
				t.traverse(child, node)
			}
		}
	case ESTreeKindArrayPattern:
		if node.(*ArrayPattern).Decorators != nil {
			for _, child := range node.(*ArrayPattern).Decorators {
				t.traverse(child, node)
			}
		}
		if node.(*ArrayPattern).Elements != nil {
			for _, child := range node.(*ArrayPattern).Elements {
				t.traverse(child, node)
			}
		}
		if node.(*ArrayPattern).TypeAnnotation != nil {
			t.traverse(node.(*ArrayPattern).TypeAnnotation, node)
		}
	case ESTreeKindArrowFunctionExpression:
		if node.(*ArrowFunctionExpression).TypeParameters != nil {
			t.traverse(node.(*ArrowFunctionExpression).TypeParameters, node)
		}
		if node.(*ArrowFunctionExpression).Params != nil {
			for _, child := range node.(*ArrowFunctionExpression).Params {
				t.traverse(child, node)
			}
		}
		if node.(*ArrowFunctionExpression).ReturnType != nil {
			t.traverse(node.(*ArrowFunctionExpression).ReturnType, node)
		}
		if node.(*ArrowFunctionExpression).Body != nil {
			t.traverse(node.(*ArrowFunctionExpression).Body, node)
		}
	case ESTreeKindAssignmentExpression:
		if node.(*AssignmentExpression).Left != nil {
			t.traverse(node.(*AssignmentExpression).Left, node)
		}
		if node.(*AssignmentExpression).Right != nil {
			t.traverse(node.(*AssignmentExpression).Right, node)
		}
	case ESTreeKindAssignmentPattern:
		if node.(*AssignmentPattern).Decorators != nil {
			for _, child := range node.(*AssignmentPattern).Decorators {
				t.traverse(child, node)
			}
		}
		if node.(*AssignmentPattern).Left != nil {
			t.traverse(node.(*AssignmentPattern).Left, node)
		}
		if node.(*AssignmentPattern).Right != nil {
			t.traverse(node.(*AssignmentPattern).Right, node)
		}
		if node.(*AssignmentPattern).TypeAnnotation != nil {
			t.traverse(node.(*AssignmentPattern).TypeAnnotation, node)
		}
	case ESTreeKindAwaitExpression:
		if node.(*AwaitExpression).Argument != nil {
			t.traverse(node.(*AwaitExpression).Argument, node)
		}
	case ESTreeKindBinaryExpression:
		if node.(*BinaryExpression).Left != nil {
			t.traverse(node.(*BinaryExpression).Left, node)
		}
		if node.(*BinaryExpression).Right != nil {
			t.traverse(node.(*BinaryExpression).Right, node)
		}
	case ESTreeKindBlockStatement:
		if node.(*BlockStatement).Body != nil {
			for _, child := range node.(*BlockStatement).Body {
				t.traverse(child, node)
			}
		}
	case ESTreeKindBreakStatement:
		if node.(*BreakStatement).Label != nil {
			t.traverse(node.(*BreakStatement).Label, node)
		}
	case ESTreeKindCallExpression:
		if node.(*CallExpression).Callee != nil {
			t.traverse(node.(*CallExpression).Callee, node)
		}
		if node.(*CallExpression).TypeArguments != nil {
			t.traverse(node.(*CallExpression).TypeArguments, node)
		}
		if node.(*CallExpression).Arguments != nil {
			for _, child := range node.(*CallExpression).Arguments {
				t.traverse(child, node)
			}
		}
	case ESTreeKindCatchClause:
		if node.(*CatchClause).Param != nil {
			t.traverse(node.(*CatchClause).Param, node)
		}
		if node.(*CatchClause).Body != nil {
			t.traverse(node.(*CatchClause).Body, node)
		}
	case ESTreeKindChainExpression:
		if node.(*ChainExpression).Expression != nil {
			t.traverse(node.(*ChainExpression).Expression, node)
		}
	case ESTreeKindClassBody:
		if node.(*ClassBody).Body != nil {
			for _, child := range node.(*ClassBody).Body {
				t.traverse(child, node)
			}
		}
	case ESTreeKindClassDeclaration:
		if node.(*ClassDeclaration).Decorators != nil {
			for _, child := range node.(*ClassDeclaration).Decorators {
				t.traverse(child, node)
			}
		}
		if node.(*ClassDeclaration).Id != nil {
			t.traverse(node.(*ClassDeclaration).Id, node)
		}
		if node.(*ClassDeclaration).TypeParameters != nil {
			t.traverse(node.(*ClassDeclaration).TypeParameters, node)
		}
		if node.(*ClassDeclaration).SuperClass != nil {
			t.traverse(node.(*ClassDeclaration).SuperClass, node)
		}
		if node.(*ClassDeclaration).SuperTypeArguments != nil {
			t.traverse(node.(*ClassDeclaration).SuperTypeArguments, node)
		}
		if node.(*ClassDeclaration).Implements != nil {
			for _, child := range node.(*ClassDeclaration).Implements {
				t.traverse(child, node)
			}
		}
		if node.(*ClassDeclaration).Body != nil {
			t.traverse(node.(*ClassDeclaration).Body, node)
		}
	case ESTreeKindClassExpression:
		if node.(*ClassExpression).Decorators != nil {
			for _, child := range node.(*ClassExpression).Decorators {
				t.traverse(child, node)
			}
		}
		if node.(*ClassExpression).Id != nil {
			t.traverse(node.(*ClassExpression).Id, node)
		}
		if node.(*ClassExpression).TypeParameters != nil {
			t.traverse(node.(*ClassExpression).TypeParameters, node)
		}
		if node.(*ClassExpression).SuperClass != nil {
			t.traverse(node.(*ClassExpression).SuperClass, node)
		}
		if node.(*ClassExpression).SuperTypeArguments != nil {
			t.traverse(node.(*ClassExpression).SuperTypeArguments, node)
		}
		if node.(*ClassExpression).Implements != nil {
			for _, child := range node.(*ClassExpression).Implements {
				t.traverse(child, node)
			}
		}
		if node.(*ClassExpression).Body != nil {
			t.traverse(node.(*ClassExpression).Body, node)
		}
	case ESTreeKindConditionalExpression:
		if node.(*ConditionalExpression).Test != nil {
			t.traverse(node.(*ConditionalExpression).Test, node)
		}
		if node.(*ConditionalExpression).Consequent != nil {
			t.traverse(node.(*ConditionalExpression).Consequent, node)
		}
		if node.(*ConditionalExpression).Alternate != nil {
			t.traverse(node.(*ConditionalExpression).Alternate, node)
		}
	case ESTreeKindContinueStatement:
		if node.(*ContinueStatement).Label != nil {
			t.traverse(node.(*ContinueStatement).Label, node)
		}
	case ESTreeKindDoWhileStatement:
		if node.(*DoWhileStatement).Body != nil {
			t.traverse(node.(*DoWhileStatement).Body, node)
		}
		if node.(*DoWhileStatement).Test != nil {
			t.traverse(node.(*DoWhileStatement).Test, node)
		}
	case ESTreeKindExportAllDeclaration:
		if node.(*ExportAllDeclaration).Exported != nil {
			t.traverse(node.(*ExportAllDeclaration).Exported, node)
		}
		if node.(*ExportAllDeclaration).Source != nil {
			t.traverse(node.(*ExportAllDeclaration).Source, node)
		}
		if node.(*ExportAllDeclaration).Attributes != nil {
			for _, child := range node.(*ExportAllDeclaration).Attributes {
				t.traverse(child, node)
			}
		}
	case ESTreeKindExportDefaultDeclaration:
		if node.(*ExportDefaultDeclaration).Declaration != nil {
			t.traverse(node.(*ExportDefaultDeclaration).Declaration, node)
		}
	case ESTreeKindExportNamedDeclaration:
		if node.(*ExportNamedDeclaration).Declaration != nil {
			t.traverse(node.(*ExportNamedDeclaration).Declaration, node)
		}
		if node.(*ExportNamedDeclaration).Specifiers != nil {
			for _, child := range node.(*ExportNamedDeclaration).Specifiers {
				t.traverse(child, node)
			}
		}
		if node.(*ExportNamedDeclaration).Source != nil {
			t.traverse(node.(*ExportNamedDeclaration).Source, node)
		}
		if node.(*ExportNamedDeclaration).Attributes != nil {
			for _, child := range node.(*ExportNamedDeclaration).Attributes {
				t.traverse(child, node)
			}
		}
	case ESTreeKindExportSpecifier:
		if node.(*ExportSpecifier).Exported != nil {
			t.traverse(node.(*ExportSpecifier).Exported, node)
		}
		if node.(*ExportSpecifier).Local != nil {
			t.traverse(node.(*ExportSpecifier).Local, node)
		}
	case ESTreeKindExpressionStatement:
		if node.(*ExpressionStatement).Expression != nil {
			t.traverse(node.(*ExpressionStatement).Expression, node)
		}
	case ESTreeKindForInStatement:
		if node.(*ForInStatement).Left != nil {
			t.traverse(node.(*ForInStatement).Left, node)
		}
		if node.(*ForInStatement).Right != nil {
			t.traverse(node.(*ForInStatement).Right, node)
		}
		if node.(*ForInStatement).Body != nil {
			t.traverse(node.(*ForInStatement).Body, node)
		}
	case ESTreeKindForOfStatement:
		if node.(*ForOfStatement).Left != nil {
			t.traverse(node.(*ForOfStatement).Left, node)
		}
		if node.(*ForOfStatement).Right != nil {
			t.traverse(node.(*ForOfStatement).Right, node)
		}
		if node.(*ForOfStatement).Body != nil {
			t.traverse(node.(*ForOfStatement).Body, node)
		}
	case ESTreeKindForStatement:
		if node.(*ForStatement).Init != nil {
			t.traverse(node.(*ForStatement).Init, node)
		}
		if node.(*ForStatement).Test != nil {
			t.traverse(node.(*ForStatement).Test, node)
		}
		if node.(*ForStatement).Update != nil {
			t.traverse(node.(*ForStatement).Update, node)
		}
		if node.(*ForStatement).Body != nil {
			t.traverse(node.(*ForStatement).Body, node)
		}
	case ESTreeKindFunctionDeclaration:
		if node.(*FunctionDeclaration).Id != nil {
			t.traverse(node.(*FunctionDeclaration).Id, node)
		}
		if node.(*FunctionDeclaration).TypeParameters != nil {
			t.traverse(node.(*FunctionDeclaration).TypeParameters, node)
		}
		if node.(*FunctionDeclaration).Params != nil {
			for _, child := range node.(*FunctionDeclaration).Params {
				t.traverse(child, node)
			}
		}
		if node.(*FunctionDeclaration).ReturnType != nil {
			t.traverse(node.(*FunctionDeclaration).ReturnType, node)
		}
		if node.(*FunctionDeclaration).Body != nil {
			t.traverse(node.(*FunctionDeclaration).Body, node)
		}
	case ESTreeKindFunctionExpression:
		if node.(*FunctionExpression).Id != nil {
			t.traverse(node.(*FunctionExpression).Id, node)
		}
		if node.(*FunctionExpression).TypeParameters != nil {
			t.traverse(node.(*FunctionExpression).TypeParameters, node)
		}
		if node.(*FunctionExpression).Params != nil {
			for _, child := range node.(*FunctionExpression).Params {
				t.traverse(child, node)
			}
		}
		if node.(*FunctionExpression).ReturnType != nil {
			t.traverse(node.(*FunctionExpression).ReturnType, node)
		}
		if node.(*FunctionExpression).Body != nil {
			t.traverse(node.(*FunctionExpression).Body, node)
		}
	case ESTreeKindIdentifier:
		if node.(*Identifier).Decorators != nil {
			for _, child := range node.(*Identifier).Decorators {
				t.traverse(child, node)
			}
		}
		if node.(*Identifier).TypeAnnotation != nil {
			t.traverse(node.(*Identifier).TypeAnnotation, node)
		}
	case ESTreeKindIfStatement:
		if node.(*IfStatement).Test != nil {
			t.traverse(node.(*IfStatement).Test, node)
		}
		if node.(*IfStatement).Consequent != nil {
			t.traverse(node.(*IfStatement).Consequent, node)
		}
		if node.(*IfStatement).Alternate != nil {
			t.traverse(node.(*IfStatement).Alternate, node)
		}
	case ESTreeKindImportAttribute:
		if node.(*ImportAttribute).Key != nil {
			t.traverse(node.(*ImportAttribute).Key, node)
		}
		if node.(*ImportAttribute).Value != nil {
			t.traverse(node.(*ImportAttribute).Value, node)
		}
	case ESTreeKindImportDeclaration:
		if node.(*ImportDeclaration).Specifiers != nil {
			for _, child := range node.(*ImportDeclaration).Specifiers {
				t.traverse(child, node)
			}
		}
		if node.(*ImportDeclaration).Source != nil {
			t.traverse(node.(*ImportDeclaration).Source, node)
		}
		if node.(*ImportDeclaration).Attributes != nil {
			for _, child := range node.(*ImportDeclaration).Attributes {
				t.traverse(child, node)
			}
		}
	case ESTreeKindImportDefaultSpecifier:
		if node.(*ImportDefaultSpecifier).Local != nil {
			t.traverse(node.(*ImportDefaultSpecifier).Local, node)
		}
	case ESTreeKindImportExpression:
		if node.(*ImportExpression).Source != nil {
			t.traverse(node.(*ImportExpression).Source, node)
		}
		if node.(*ImportExpression).Options != nil {
			t.traverse(node.(*ImportExpression).Options, node)
		}
	case ESTreeKindImportNamespaceSpecifier:
		if node.(*ImportNamespaceSpecifier).Local != nil {
			t.traverse(node.(*ImportNamespaceSpecifier).Local, node)
		}
	case ESTreeKindImportSpecifier:
		if node.(*ImportSpecifier).Imported != nil {
			t.traverse(node.(*ImportSpecifier).Imported, node)
		}
		if node.(*ImportSpecifier).Local != nil {
			t.traverse(node.(*ImportSpecifier).Local, node)
		}
	case ESTreeKindJSXAttribute:
		if node.(*JSXAttribute).Name != nil {
			t.traverse(node.(*JSXAttribute).Name, node)
		}
		if node.(*JSXAttribute).Value != nil {
			t.traverse(node.(*JSXAttribute).Value, node)
		}
	case ESTreeKindJSXClosingElement:
		if node.(*JSXClosingElement).Name != nil {
			t.traverse(node.(*JSXClosingElement).Name, node)
		}
	case ESTreeKindJSXElement:
		if node.(*JSXElement).OpeningElement != nil {
			t.traverse(node.(*JSXElement).OpeningElement, node)
		}
		if node.(*JSXElement).Children != nil {
			for _, child := range node.(*JSXElement).Children {
				t.traverse(child, node)
			}
		}
		if node.(*JSXElement).ClosingElement != nil {
			t.traverse(node.(*JSXElement).ClosingElement, node)
		}
	case ESTreeKindJSXExpressionContainer:
		if node.(*JSXExpressionContainer).Expression != nil {
			t.traverse(node.(*JSXExpressionContainer).Expression, node)
		}
	case ESTreeKindJSXFragment:
		if node.(*JSXFragment).OpeningFragment != nil {
			t.traverse(node.(*JSXFragment).OpeningFragment, node)
		}
		if node.(*JSXFragment).Children != nil {
			for _, child := range node.(*JSXFragment).Children {
				t.traverse(child, node)
			}
		}
		if node.(*JSXFragment).ClosingFragment != nil {
			t.traverse(node.(*JSXFragment).ClosingFragment, node)
		}
	case ESTreeKindJSXMemberExpression:
		if node.(*JSXMemberExpression).Object != nil {
			t.traverse(node.(*JSXMemberExpression).Object, node)
		}
		if node.(*JSXMemberExpression).Property != nil {
			t.traverse(node.(*JSXMemberExpression).Property, node)
		}
	case ESTreeKindJSXNamespacedName:
		if node.(*JSXNamespacedName).Namespace != nil {
			t.traverse(node.(*JSXNamespacedName).Namespace, node)
		}
		if node.(*JSXNamespacedName).Name != nil {
			t.traverse(node.(*JSXNamespacedName).Name, node)
		}
	case ESTreeKindJSXOpeningElement:
		if node.(*JSXOpeningElement).Name != nil {
			t.traverse(node.(*JSXOpeningElement).Name, node)
		}
		if node.(*JSXOpeningElement).TypeArguments != nil {
			t.traverse(node.(*JSXOpeningElement).TypeArguments, node)
		}
		if node.(*JSXOpeningElement).Attributes != nil {
			for _, child := range node.(*JSXOpeningElement).Attributes {
				t.traverse(child, node)
			}
		}
	case ESTreeKindJSXSpreadAttribute:
		if node.(*JSXSpreadAttribute).Argument != nil {
			t.traverse(node.(*JSXSpreadAttribute).Argument, node)
		}
	case ESTreeKindJSXSpreadChild:
		if node.(*JSXSpreadChild).Expression != nil {
			t.traverse(node.(*JSXSpreadChild).Expression, node)
		}
	case ESTreeKindLabeledStatement:
		if node.(*LabeledStatement).Label != nil {
			t.traverse(node.(*LabeledStatement).Label, node)
		}
		if node.(*LabeledStatement).Body != nil {
			t.traverse(node.(*LabeledStatement).Body, node)
		}
	case ESTreeKindLogicalExpression:
		if node.(*LogicalExpression).Left != nil {
			t.traverse(node.(*LogicalExpression).Left, node)
		}
		if node.(*LogicalExpression).Right != nil {
			t.traverse(node.(*LogicalExpression).Right, node)
		}
	case ESTreeKindMemberExpression:
		if node.(*MemberExpression).Object != nil {
			t.traverse(node.(*MemberExpression).Object, node)
		}
		if node.(*MemberExpression).Property != nil {
			t.traverse(node.(*MemberExpression).Property, node)
		}
	case ESTreeKindMetaProperty:
		if node.(*MetaProperty).Meta != nil {
			t.traverse(node.(*MetaProperty).Meta, node)
		}
		if node.(*MetaProperty).Property != nil {
			t.traverse(node.(*MetaProperty).Property, node)
		}
	case ESTreeKindMethodDefinition:
		if node.(*MethodDefinition).Decorators != nil {
			for _, child := range node.(*MethodDefinition).Decorators {
				t.traverse(child, node)
			}
		}
		if node.(*MethodDefinition).Key != nil {
			t.traverse(node.(*MethodDefinition).Key, node)
		}
		if node.(*MethodDefinition).Value != nil {
			t.traverse(node.(*MethodDefinition).Value, node)
		}
	case ESTreeKindNewExpression:
		if node.(*NewExpression).Callee != nil {
			t.traverse(node.(*NewExpression).Callee, node)
		}
		if node.(*NewExpression).TypeArguments != nil {
			t.traverse(node.(*NewExpression).TypeArguments, node)
		}
		if node.(*NewExpression).Arguments != nil {
			for _, child := range node.(*NewExpression).Arguments {
				t.traverse(child, node)
			}
		}
	case ESTreeKindObjectExpression:
		if node.(*ObjectExpression).Properties != nil {
			for _, child := range node.(*ObjectExpression).Properties {
				t.traverse(child, node)
			}
		}
	case ESTreeKindObjectPattern:
		if node.(*ObjectPattern).Decorators != nil {
			for _, child := range node.(*ObjectPattern).Decorators {
				t.traverse(child, node)
			}
		}
		if node.(*ObjectPattern).Properties != nil {
			for _, child := range node.(*ObjectPattern).Properties {
				t.traverse(child, node)
			}
		}
		if node.(*ObjectPattern).TypeAnnotation != nil {
			t.traverse(node.(*ObjectPattern).TypeAnnotation, node)
		}
	case ESTreeKindProgram:
		if node.(*Program).Body != nil {
			for _, child := range node.(*Program).Body {
				t.traverse(child, node)
			}
		}
	case ESTreeKindProperty:
		if node.(*Property).Key != nil {
			t.traverse(node.(*Property).Key, node)
		}
		if node.(*Property).Value != nil {
			t.traverse(node.(*Property).Value, node)
		}
	case ESTreeKindPropertyDefinition:
		if node.(*PropertyDefinition).Decorators != nil {
			for _, child := range node.(*PropertyDefinition).Decorators {
				t.traverse(child, node)
			}
		}
		if node.(*PropertyDefinition).Key != nil {
			t.traverse(node.(*PropertyDefinition).Key, node)
		}
		if node.(*PropertyDefinition).TypeAnnotation != nil {
			t.traverse(node.(*PropertyDefinition).TypeAnnotation, node)
		}
		if node.(*PropertyDefinition).Value != nil {
			t.traverse(node.(*PropertyDefinition).Value, node)
		}
	case ESTreeKindRestElement:
		if node.(*RestElement).Decorators != nil {
			for _, child := range node.(*RestElement).Decorators {
				t.traverse(child, node)
			}
		}
		if node.(*RestElement).Argument != nil {
			t.traverse(node.(*RestElement).Argument, node)
		}
		if node.(*RestElement).TypeAnnotation != nil {
			t.traverse(node.(*RestElement).TypeAnnotation, node)
		}
	case ESTreeKindReturnStatement:
		if node.(*ReturnStatement).Argument != nil {
			t.traverse(node.(*ReturnStatement).Argument, node)
		}
	case ESTreeKindSequenceExpression:
		if node.(*SequenceExpression).Expressions != nil {
			for _, child := range node.(*SequenceExpression).Expressions {
				t.traverse(child, node)
			}
		}
	case ESTreeKindSpreadElement:
		if node.(*SpreadElement).Argument != nil {
			t.traverse(node.(*SpreadElement).Argument, node)
		}
	case ESTreeKindStaticBlock:
		if node.(*StaticBlock).Body != nil {
			for _, child := range node.(*StaticBlock).Body {
				t.traverse(child, node)
			}
		}
	case ESTreeKindSwitchCase:
		if node.(*SwitchCase).Test != nil {
			t.traverse(node.(*SwitchCase).Test, node)
		}
		if node.(*SwitchCase).Consequent != nil {
			for _, child := range node.(*SwitchCase).Consequent {
				t.traverse(child, node)
			}
		}
	case ESTreeKindSwitchStatement:
		if node.(*SwitchStatement).Discriminant != nil {
			t.traverse(node.(*SwitchStatement).Discriminant, node)
		}
		if node.(*SwitchStatement).Cases != nil {
			for _, child := range node.(*SwitchStatement).Cases {
				t.traverse(child, node)
			}
		}
	case ESTreeKindTaggedTemplateExpression:
		if node.(*TaggedTemplateExpression).Tag != nil {
			t.traverse(node.(*TaggedTemplateExpression).Tag, node)
		}
		if node.(*TaggedTemplateExpression).TypeArguments != nil {
			t.traverse(node.(*TaggedTemplateExpression).TypeArguments, node)
		}
		if node.(*TaggedTemplateExpression).Quasi != nil {
			t.traverse(node.(*TaggedTemplateExpression).Quasi, node)
		}
	case ESTreeKindTemplateLiteral:
		if node.(*TemplateLiteral).Quasis != nil {
			for _, child := range node.(*TemplateLiteral).Quasis {
				t.traverse(child, node)
			}
		}
		if node.(*TemplateLiteral).Expressions != nil {
			for _, child := range node.(*TemplateLiteral).Expressions {
				t.traverse(child, node)
			}
		}
	case ESTreeKindThrowStatement:
		if node.(*ThrowStatement).Argument != nil {
			t.traverse(node.(*ThrowStatement).Argument, node)
		}
	case ESTreeKindTryStatement:
		if node.(*TryStatement).Block != nil {
			t.traverse(node.(*TryStatement).Block, node)
		}
		if node.(*TryStatement).Handler != nil {
			t.traverse(node.(*TryStatement).Handler, node)
		}
		if node.(*TryStatement).Finalizer != nil {
			t.traverse(node.(*TryStatement).Finalizer, node)
		}
	case ESTreeKindUnaryExpression:
		if node.(*UnaryExpression).Argument != nil {
			t.traverse(node.(*UnaryExpression).Argument, node)
		}
	case ESTreeKindUpdateExpression:
		if node.(*UpdateExpression).Argument != nil {
			t.traverse(node.(*UpdateExpression).Argument, node)
		}
	case ESTreeKindVariableDeclaration:
		if node.(*VariableDeclaration).Declarations != nil {
			for _, child := range node.(*VariableDeclaration).Declarations {
				t.traverse(child, node)
			}
		}
	case ESTreeKindVariableDeclarator:
		if node.(*VariableDeclarator).Id != nil {
			t.traverse(node.(*VariableDeclarator).Id, node)
		}
		if node.(*VariableDeclarator).Init != nil {
			t.traverse(node.(*VariableDeclarator).Init, node)
		}
	case ESTreeKindWhileStatement:
		if node.(*WhileStatement).Test != nil {
			t.traverse(node.(*WhileStatement).Test, node)
		}
		if node.(*WhileStatement).Body != nil {
			t.traverse(node.(*WhileStatement).Body, node)
		}
	case ESTreeKindWithStatement:
		if node.(*WithStatement).Object != nil {
			t.traverse(node.(*WithStatement).Object, node)
		}
		if node.(*WithStatement).Body != nil {
			t.traverse(node.(*WithStatement).Body, node)
		}
	case ESTreeKindYieldExpression:
		if node.(*YieldExpression).Argument != nil {
			t.traverse(node.(*YieldExpression).Argument, node)
		}
	case ESTreeKindAccessorProperty:
		if node.(*AccessorProperty).Decorators != nil {
			for _, child := range node.(*AccessorProperty).Decorators {
				t.traverse(child, node)
			}
		}
		if node.(*AccessorProperty).Key != nil {
			t.traverse(node.(*AccessorProperty).Key, node)
		}
		if node.(*AccessorProperty).TypeAnnotation != nil {
			t.traverse(node.(*AccessorProperty).TypeAnnotation, node)
		}
		if node.(*AccessorProperty).Value != nil {
			t.traverse(node.(*AccessorProperty).Value, node)
		}
	case ESTreeKindDecorator:
		if node.(*Decorator).Expression != nil {
			t.traverse(node.(*Decorator).Expression, node)
		}
	case ESTreeKindTSAbstractAccessorProperty:
		if node.(*TSAbstractAccessorProperty).Decorators != nil {
			for _, child := range node.(*TSAbstractAccessorProperty).Decorators {
				t.traverse(child, node)
			}
		}
		if node.(*TSAbstractAccessorProperty).Key != nil {
			t.traverse(node.(*TSAbstractAccessorProperty).Key, node)
		}
		if node.(*TSAbstractAccessorProperty).TypeAnnotation != nil {
			t.traverse(node.(*TSAbstractAccessorProperty).TypeAnnotation, node)
		}
	case ESTreeKindTSAbstractMethodDefinition:
		if node.(*TSAbstractMethodDefinition).Key != nil {
			t.traverse(node.(*TSAbstractMethodDefinition).Key, node)
		}
		if node.(*TSAbstractMethodDefinition).Value != nil {
			t.traverse(node.(*TSAbstractMethodDefinition).Value, node)
		}
	case ESTreeKindTSAbstractPropertyDefinition:
		if node.(*TSAbstractPropertyDefinition).Decorators != nil {
			for _, child := range node.(*TSAbstractPropertyDefinition).Decorators {
				t.traverse(child, node)
			}
		}
		if node.(*TSAbstractPropertyDefinition).Key != nil {
			t.traverse(node.(*TSAbstractPropertyDefinition).Key, node)
		}
		if node.(*TSAbstractPropertyDefinition).TypeAnnotation != nil {
			t.traverse(node.(*TSAbstractPropertyDefinition).TypeAnnotation, node)
		}
	case ESTreeKindTSArrayType:
		if node.(*TSArrayType).ElementType != nil {
			t.traverse(node.(*TSArrayType).ElementType, node)
		}
	case ESTreeKindTSAsExpression:
		if node.(*TSAsExpression).Expression != nil {
			t.traverse(node.(*TSAsExpression).Expression, node)
		}
		if node.(*TSAsExpression).TypeAnnotation != nil {
			t.traverse(node.(*TSAsExpression).TypeAnnotation, node)
		}
	case ESTreeKindTSCallSignatureDeclaration:
		if node.(*TSCallSignatureDeclaration).TypeParameters != nil {
			t.traverse(node.(*TSCallSignatureDeclaration).TypeParameters, node)
		}
		if node.(*TSCallSignatureDeclaration).Params != nil {
			for _, child := range node.(*TSCallSignatureDeclaration).Params {
				t.traverse(child, node)
			}
		}
		if node.(*TSCallSignatureDeclaration).ReturnType != nil {
			t.traverse(node.(*TSCallSignatureDeclaration).ReturnType, node)
		}
	case ESTreeKindTSClassImplements:
		if node.(*TSClassImplements).Expression != nil {
			t.traverse(node.(*TSClassImplements).Expression, node)
		}
		if node.(*TSClassImplements).TypeArguments != nil {
			t.traverse(node.(*TSClassImplements).TypeArguments, node)
		}
	case ESTreeKindTSConditionalType:
		if node.(*TSConditionalType).CheckType != nil {
			t.traverse(node.(*TSConditionalType).CheckType, node)
		}
		if node.(*TSConditionalType).ExtendsType != nil {
			t.traverse(node.(*TSConditionalType).ExtendsType, node)
		}
		if node.(*TSConditionalType).TrueType != nil {
			t.traverse(node.(*TSConditionalType).TrueType, node)
		}
		if node.(*TSConditionalType).FalseType != nil {
			t.traverse(node.(*TSConditionalType).FalseType, node)
		}
	case ESTreeKindTSConstructorType:
		if node.(*TSConstructorType).TypeParameters != nil {
			t.traverse(node.(*TSConstructorType).TypeParameters, node)
		}
		if node.(*TSConstructorType).Params != nil {
			for _, child := range node.(*TSConstructorType).Params {
				t.traverse(child, node)
			}
		}
		if node.(*TSConstructorType).ReturnType != nil {
			t.traverse(node.(*TSConstructorType).ReturnType, node)
		}
	case ESTreeKindTSConstructSignatureDeclaration:
		if node.(*TSConstructSignatureDeclaration).TypeParameters != nil {
			t.traverse(node.(*TSConstructSignatureDeclaration).TypeParameters, node)
		}
		if node.(*TSConstructSignatureDeclaration).Params != nil {
			for _, child := range node.(*TSConstructSignatureDeclaration).Params {
				t.traverse(child, node)
			}
		}
		if node.(*TSConstructSignatureDeclaration).ReturnType != nil {
			t.traverse(node.(*TSConstructSignatureDeclaration).ReturnType, node)
		}
	case ESTreeKindTSDeclareFunction:
		if node.(*TSDeclareFunction).Id != nil {
			t.traverse(node.(*TSDeclareFunction).Id, node)
		}
		if node.(*TSDeclareFunction).TypeParameters != nil {
			t.traverse(node.(*TSDeclareFunction).TypeParameters, node)
		}
		if node.(*TSDeclareFunction).Params != nil {
			for _, child := range node.(*TSDeclareFunction).Params {
				t.traverse(child, node)
			}
		}
		if node.(*TSDeclareFunction).ReturnType != nil {
			t.traverse(node.(*TSDeclareFunction).ReturnType, node)
		}
		if node.(*TSDeclareFunction).Body != nil {
			t.traverse(node.(*TSDeclareFunction).Body, node)
		}
	case ESTreeKindTSEmptyBodyFunctionExpression:
		if node.(*TSEmptyBodyFunctionExpression).Id != nil {
			t.traverse(node.(*TSEmptyBodyFunctionExpression).Id, node)
		}
		if node.(*TSEmptyBodyFunctionExpression).TypeParameters != nil {
			t.traverse(node.(*TSEmptyBodyFunctionExpression).TypeParameters, node)
		}
		if node.(*TSEmptyBodyFunctionExpression).Params != nil {
			for _, child := range node.(*TSEmptyBodyFunctionExpression).Params {
				t.traverse(child, node)
			}
		}
		if node.(*TSEmptyBodyFunctionExpression).ReturnType != nil {
			t.traverse(node.(*TSEmptyBodyFunctionExpression).ReturnType, node)
		}
	case ESTreeKindTSEnumBody:
		if node.(*TSEnumBody).Members != nil {
			for _, child := range node.(*TSEnumBody).Members {
				t.traverse(child, node)
			}
		}
	case ESTreeKindTSEnumDeclaration:
		if node.(*TSEnumDeclaration).Id != nil {
			t.traverse(node.(*TSEnumDeclaration).Id, node)
		}
		if node.(*TSEnumDeclaration).Body != nil {
			t.traverse(node.(*TSEnumDeclaration).Body, node)
		}
	case ESTreeKindTSEnumMember:
		if node.(*TSEnumMember).Id != nil {
			t.traverse(node.(*TSEnumMember).Id, node)
		}
		if node.(*TSEnumMember).Initializer != nil {
			t.traverse(node.(*TSEnumMember).Initializer, node)
		}
	case ESTreeKindTSExportAssignment:
		if node.(*TSExportAssignment).Expression != nil {
			t.traverse(node.(*TSExportAssignment).Expression, node)
		}
	case ESTreeKindTSExternalModuleReference:
		if node.(*TSExternalModuleReference).Expression != nil {
			t.traverse(node.(*TSExternalModuleReference).Expression, node)
		}
	case ESTreeKindTSFunctionType:
		if node.(*TSFunctionType).TypeParameters != nil {
			t.traverse(node.(*TSFunctionType).TypeParameters, node)
		}
		if node.(*TSFunctionType).Params != nil {
			for _, child := range node.(*TSFunctionType).Params {
				t.traverse(child, node)
			}
		}
		if node.(*TSFunctionType).ReturnType != nil {
			t.traverse(node.(*TSFunctionType).ReturnType, node)
		}
	case ESTreeKindTSImportEqualsDeclaration:
		if node.(*TSImportEqualsDeclaration).Id != nil {
			t.traverse(node.(*TSImportEqualsDeclaration).Id, node)
		}
		if node.(*TSImportEqualsDeclaration).ModuleReference != nil {
			t.traverse(node.(*TSImportEqualsDeclaration).ModuleReference, node)
		}
	case ESTreeKindTSImportType:
		if node.(*TSImportType).Argument != nil {
			t.traverse(node.(*TSImportType).Argument, node)
		}
		if node.(*TSImportType).Qualifier != nil {
			t.traverse(node.(*TSImportType).Qualifier, node)
		}
		if node.(*TSImportType).TypeArguments != nil {
			t.traverse(node.(*TSImportType).TypeArguments, node)
		}
		if node.(*TSImportType).Options != nil {
			t.traverse(node.(*TSImportType).Options, node)
		}
	case ESTreeKindTSIndexedAccessType:
		if node.(*TSIndexedAccessType).IndexType != nil {
			t.traverse(node.(*TSIndexedAccessType).IndexType, node)
		}
		if node.(*TSIndexedAccessType).ObjectType != nil {
			t.traverse(node.(*TSIndexedAccessType).ObjectType, node)
		}
	case ESTreeKindTSIndexSignature:
		if node.(*TSIndexSignature).Parameters != nil {
			for _, child := range node.(*TSIndexSignature).Parameters {
				t.traverse(child, node)
			}
		}
		if node.(*TSIndexSignature).TypeAnnotation != nil {
			t.traverse(node.(*TSIndexSignature).TypeAnnotation, node)
		}
	case ESTreeKindTSInferType:
		if node.(*TSInferType).TypeParameter != nil {
			t.traverse(node.(*TSInferType).TypeParameter, node)
		}
	case ESTreeKindTSInstantiationExpression:
		if node.(*TSInstantiationExpression).Expression != nil {
			t.traverse(node.(*TSInstantiationExpression).Expression, node)
		}
		if node.(*TSInstantiationExpression).TypeArguments != nil {
			t.traverse(node.(*TSInstantiationExpression).TypeArguments, node)
		}
	case ESTreeKindTSInterfaceBody:
		if node.(*TSInterfaceBody).Body != nil {
			for _, child := range node.(*TSInterfaceBody).Body {
				t.traverse(child, node)
			}
		}
	case ESTreeKindTSInterfaceDeclaration:
		if node.(*TSInterfaceDeclaration).Id != nil {
			t.traverse(node.(*TSInterfaceDeclaration).Id, node)
		}
		if node.(*TSInterfaceDeclaration).TypeParameters != nil {
			t.traverse(node.(*TSInterfaceDeclaration).TypeParameters, node)
		}
		if node.(*TSInterfaceDeclaration).Extends != nil {
			for _, child := range node.(*TSInterfaceDeclaration).Extends {
				t.traverse(child, node)
			}
		}
		if node.(*TSInterfaceDeclaration).Body != nil {
			t.traverse(node.(*TSInterfaceDeclaration).Body, node)
		}
	case ESTreeKindTSInterfaceHeritage:
		if node.(*TSInterfaceHeritage).Expression != nil {
			t.traverse(node.(*TSInterfaceHeritage).Expression, node)
		}
		if node.(*TSInterfaceHeritage).TypeArguments != nil {
			t.traverse(node.(*TSInterfaceHeritage).TypeArguments, node)
		}
	case ESTreeKindTSIntersectionType:
		if node.(*TSIntersectionType).Types != nil {
			for _, child := range node.(*TSIntersectionType).Types {
				t.traverse(child, node)
			}
		}
	case ESTreeKindTSLiteralType:
		if node.(*TSLiteralType).Literal != nil {
			t.traverse(node.(*TSLiteralType).Literal, node)
		}
	case ESTreeKindTSMappedType:
		if node.(*TSMappedType).Key != nil {
			t.traverse(node.(*TSMappedType).Key, node)
		}
		if node.(*TSMappedType).Constraint != nil {
			t.traverse(node.(*TSMappedType).Constraint, node)
		}
		if node.(*TSMappedType).NameType != nil {
			t.traverse(node.(*TSMappedType).NameType, node)
		}
		if node.(*TSMappedType).TypeAnnotation != nil {
			t.traverse(node.(*TSMappedType).TypeAnnotation, node)
		}
	case ESTreeKindTSMethodSignature:
		if node.(*TSMethodSignature).TypeParameters != nil {
			t.traverse(node.(*TSMethodSignature).TypeParameters, node)
		}
		if node.(*TSMethodSignature).Key != nil {
			t.traverse(node.(*TSMethodSignature).Key, node)
		}
		if node.(*TSMethodSignature).Params != nil {
			for _, child := range node.(*TSMethodSignature).Params {
				t.traverse(child, node)
			}
		}
		if node.(*TSMethodSignature).ReturnType != nil {
			t.traverse(node.(*TSMethodSignature).ReturnType, node)
		}
	case ESTreeKindTSModuleBlock:
		if node.(*TSModuleBlock).Body != nil {
			for _, child := range node.(*TSModuleBlock).Body {
				t.traverse(child, node)
			}
		}
	case ESTreeKindTSModuleDeclaration:
		if node.(*TSModuleDeclaration).Id != nil {
			t.traverse(node.(*TSModuleDeclaration).Id, node)
		}
		if node.(*TSModuleDeclaration).Body != nil {
			t.traverse(node.(*TSModuleDeclaration).Body, node)
		}
	case ESTreeKindTSNamedTupleMember:
		if node.(*TSNamedTupleMember).Label != nil {
			t.traverse(node.(*TSNamedTupleMember).Label, node)
		}
		if node.(*TSNamedTupleMember).ElementType != nil {
			t.traverse(node.(*TSNamedTupleMember).ElementType, node)
		}
	case ESTreeKindTSNamespaceExportDeclaration:
		if node.(*TSNamespaceExportDeclaration).Id != nil {
			t.traverse(node.(*TSNamespaceExportDeclaration).Id, node)
		}
	case ESTreeKindTSNonNullExpression:
		if node.(*TSNonNullExpression).Expression != nil {
			t.traverse(node.(*TSNonNullExpression).Expression, node)
		}
	case ESTreeKindTSOptionalType:
		if node.(*TSOptionalType).TypeAnnotation != nil {
			t.traverse(node.(*TSOptionalType).TypeAnnotation, node)
		}
	case ESTreeKindTSParameterProperty:
		if node.(*TSParameterProperty).Decorators != nil {
			for _, child := range node.(*TSParameterProperty).Decorators {
				t.traverse(child, node)
			}
		}
		if node.(*TSParameterProperty).Parameter != nil {
			t.traverse(node.(*TSParameterProperty).Parameter, node)
		}
	case ESTreeKindTSPropertySignature:
		if node.(*TSPropertySignature).TypeAnnotation != nil {
			t.traverse(node.(*TSPropertySignature).TypeAnnotation, node)
		}
		if node.(*TSPropertySignature).Key != nil {
			t.traverse(node.(*TSPropertySignature).Key, node)
		}
	case ESTreeKindTSQualifiedName:
		if node.(*TSQualifiedName).Left != nil {
			t.traverse(node.(*TSQualifiedName).Left, node)
		}
		if node.(*TSQualifiedName).Right != nil {
			t.traverse(node.(*TSQualifiedName).Right, node)
		}
	case ESTreeKindTSRestType:
		if node.(*TSRestType).TypeAnnotation != nil {
			t.traverse(node.(*TSRestType).TypeAnnotation, node)
		}
	case ESTreeKindTSSatisfiesExpression:
		if node.(*TSSatisfiesExpression).Expression != nil {
			t.traverse(node.(*TSSatisfiesExpression).Expression, node)
		}
		if node.(*TSSatisfiesExpression).TypeAnnotation != nil {
			t.traverse(node.(*TSSatisfiesExpression).TypeAnnotation, node)
		}
	case ESTreeKindTSTemplateLiteralType:
		if node.(*TSTemplateLiteralType).Quasis != nil {
			for _, child := range node.(*TSTemplateLiteralType).Quasis {
				t.traverse(child, node)
			}
		}
		if node.(*TSTemplateLiteralType).Types != nil {
			for _, child := range node.(*TSTemplateLiteralType).Types {
				t.traverse(child, node)
			}
		}
	case ESTreeKindTSTupleType:
		if node.(*TSTupleType).ElementTypes != nil {
			for _, child := range node.(*TSTupleType).ElementTypes {
				t.traverse(child, node)
			}
		}
	case ESTreeKindTSTypeAliasDeclaration:
		if node.(*TSTypeAliasDeclaration).Id != nil {
			t.traverse(node.(*TSTypeAliasDeclaration).Id, node)
		}
		if node.(*TSTypeAliasDeclaration).TypeParameters != nil {
			t.traverse(node.(*TSTypeAliasDeclaration).TypeParameters, node)
		}
		if node.(*TSTypeAliasDeclaration).TypeAnnotation != nil {
			t.traverse(node.(*TSTypeAliasDeclaration).TypeAnnotation, node)
		}
	case ESTreeKindTSTypeAnnotation:
		if node.(*TSTypeAnnotation).TypeAnnotation != nil {
			t.traverse(node.(*TSTypeAnnotation).TypeAnnotation, node)
		}
	case ESTreeKindTSTypeAssertion:
		if node.(*TSTypeAssertion).TypeAnnotation != nil {
			t.traverse(node.(*TSTypeAssertion).TypeAnnotation, node)
		}
		if node.(*TSTypeAssertion).Expression != nil {
			t.traverse(node.(*TSTypeAssertion).Expression, node)
		}
	case ESTreeKindTSTypeLiteral:
		if node.(*TSTypeLiteral).Members != nil {
			for _, child := range node.(*TSTypeLiteral).Members {
				t.traverse(child, node)
			}
		}
	case ESTreeKindTSTypeOperator:
		if node.(*TSTypeOperator).TypeAnnotation != nil {
			t.traverse(node.(*TSTypeOperator).TypeAnnotation, node)
		}
	case ESTreeKindTSTypeParameter:
		if node.(*TSTypeParameter).Name != nil {
			t.traverse(node.(*TSTypeParameter).Name, node)
		}
		if node.(*TSTypeParameter).Constraint != nil {
			t.traverse(node.(*TSTypeParameter).Constraint, node)
		}
		if node.(*TSTypeParameter).Default != nil {
			t.traverse(node.(*TSTypeParameter).Default, node)
		}
	case ESTreeKindTSTypeParameterDeclaration:
		if node.(*TSTypeParameterDeclaration).Params != nil {
			for _, child := range node.(*TSTypeParameterDeclaration).Params {
				t.traverse(child, node)
			}
		}
	case ESTreeKindTSTypeParameterInstantiation:
		if node.(*TSTypeParameterInstantiation).Params != nil {
			for _, child := range node.(*TSTypeParameterInstantiation).Params {
				t.traverse(child, node)
			}
		}
	case ESTreeKindTSTypePredicate:
		if node.(*TSTypePredicate).TypeAnnotation != nil {
			t.traverse(node.(*TSTypePredicate).TypeAnnotation, node)
		}
		if node.(*TSTypePredicate).ParameterName != nil {
			t.traverse(node.(*TSTypePredicate).ParameterName, node)
		}
	case ESTreeKindTSTypeQuery:
		if node.(*TSTypeQuery).ExprName != nil {
			t.traverse(node.(*TSTypeQuery).ExprName, node)
		}
		if node.(*TSTypeQuery).TypeArguments != nil {
			t.traverse(node.(*TSTypeQuery).TypeArguments, node)
		}
	case ESTreeKindTSTypeReference:
		if node.(*TSTypeReference).TypeName != nil {
			t.traverse(node.(*TSTypeReference).TypeName, node)
		}
		if node.(*TSTypeReference).TypeArguments != nil {
			t.traverse(node.(*TSTypeReference).TypeArguments, node)
		}
	case ESTreeKindTSUnionType:
		if node.(*TSUnionType).Types != nil {
			for _, child := range node.(*TSUnionType).Types {
				t.traverse(child, node)
			}
		}
	}
}
