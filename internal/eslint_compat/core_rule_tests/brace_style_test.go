// Code generated by gen-eslint-core-rule-tests.ts. DO NOT EDIT.

package core_rule_tests

import (
	"testing"
)

func TestBraceStyleRule(t *testing.T) {
	RunRuleTester(t, "{\"languageOptions\":{\"ecmaVersion\":6,\"sourceType\":\"script\"}}", "brace-style", []ValidTestCase{
		{Code: `function f() {
   if (true)
       return {x: 1}
   else {
       var y = 2
       return y
   }
}`},
		{Code: `if (tag === 1) glyph.id = pbf.readVarint();
else if (tag === 2) glyph.bitmap = pbf.readBytes();`},
		{Code: `function foo () { 
return; 
}`},
		{Code: `function a(b,
c,
d) { }`},
		{Code: `!function foo () { 
return;
 }`},
		{Code: `!function a(b,
c,
d) { }`},
		{Code: `if (foo) { 
 bar(); 
}`},
		{Code: `if (a) { 
b();
 } else { 
c();
 }`},
		{Code: `while (foo) { 
 bar();
 }`},
		{Code: `for (;;) { 
 bar(); 
}`},
		{Code: `with (foo) { 
 bar(); 
}`},
		{Code: `switch (foo) { 
 case "bar": break;
 }`},
		{Code: `try { 
 bar();
 } catch (e) {
 baz(); 
 }`},
		{Code: `do { 
 bar();
 } while (true)`},
		{Code: `for (foo in bar) { 
 baz(); 
 }`},
		{Code: `if (a &&
 b &&
 c) { 
 }`},
		{Code: `switch(0) {
}`},
		{Code: `class Foo {
}`},
		{Code: `(class {
})`},
		{Code: `class
Foo {
}`},
		{Code: `
            class Foo {
                bar() {

                }
            }
        `},
		{
			Code: `if (foo) {
}
else {
}`,
			Options: "[\"stroustrup\"]",
		},
		{
			Code: `if (foo)
{
}
else
{
}`,
			Options: "[\"allman\"]",
		},
		{
			Code: `try { 
 bar();
 }
catch (e) {
 baz(); 
 }`,
			Options: "[\"stroustrup\"]",
		},
		{
			Code: `try
{
 bar();
}
catch (e)
{
 baz(); 
}`,
			Options: "[\"allman\"]",
		},
		{
			Code:    `function foo () { return; }`,
			Options: "[\"1tbs\",{\"allowSingleLine\":true}]",
		},
		{
			Code:    `function foo () { a(); b(); return; }`,
			Options: "[\"1tbs\",{\"allowSingleLine\":true}]",
		},
		{
			Code:    `function a(b,c,d) { }`,
			Options: "[\"1tbs\",{\"allowSingleLine\":true}]",
		},
		{
			Code:    `!function foo () { return; }`,
			Options: "[\"1tbs\",{\"allowSingleLine\":true}]",
		},
		{
			Code:    `!function a(b,c,d) { }`,
			Options: "[\"1tbs\",{\"allowSingleLine\":true}]",
		},
		{
			Code:    `if (foo) {  bar(); }`,
			Options: "[\"1tbs\",{\"allowSingleLine\":true}]",
		},
		{
			Code:    `if (a) { b(); } else { c(); }`,
			Options: "[\"1tbs\",{\"allowSingleLine\":true}]",
		},
		{
			Code:    `while (foo) {  bar(); }`,
			Options: "[\"1tbs\",{\"allowSingleLine\":true}]",
		},
		{
			Code:    `for (;;) {  bar(); }`,
			Options: "[\"1tbs\",{\"allowSingleLine\":true}]",
		},
		{
			Code:    `with (foo) {  bar(); }`,
			Options: "[\"1tbs\",{\"allowSingleLine\":true}]",
		},
		{
			Code:    `switch (foo) {  case "bar": break; }`,
			Options: "[\"1tbs\",{\"allowSingleLine\":true}]",
		},
		{
			Code:    `try {  bar(); } catch (e) { baz();  }`,
			Options: "[\"1tbs\",{\"allowSingleLine\":true}]",
		},
		{
			Code:    `do {  bar(); } while (true)`,
			Options: "[\"1tbs\",{\"allowSingleLine\":true}]",
		},
		{
			Code:    `for (foo in bar) {  baz();  }`,
			Options: "[\"1tbs\",{\"allowSingleLine\":true}]",
		},
		{
			Code:    `if (a && b && c) {  }`,
			Options: "[\"1tbs\",{\"allowSingleLine\":true}]",
		},
		{
			Code:    `switch(0) {}`,
			Options: "[\"1tbs\",{\"allowSingleLine\":true}]",
		},
		{
			Code: `if (foo) {}
else {}`,
			Options: "[\"stroustrup\",{\"allowSingleLine\":true}]",
		},
		{
			Code: `try {  bar(); }
catch (e) { baz();  }`,
			Options: "[\"stroustrup\",{\"allowSingleLine\":true}]",
		},
		{
			Code:            `var foo = () => { return; }`,
			Options:         "[\"stroustrup\",{\"allowSingleLine\":true}]",
			LanguageOptions: "{\"ecmaVersion\":6}",
		},
		{
			Code: `if (foo) {}
else {}`,
			Options: "[\"allman\",{\"allowSingleLine\":true}]",
		},
		{
			Code: `try {  bar(); }
catch (e) { baz();  }`,
			Options: "[\"allman\",{\"allowSingleLine\":true}]",
		},
		{
			Code:            `var foo = () => { return; }`,
			Options:         "[\"allman\",{\"allowSingleLine\":true}]",
			LanguageOptions: "{\"ecmaVersion\":6}",
		},
		{
			Code: `if (foo) { baz(); } else {
  boom();
}`,
			Options: "[\"1tbs\",{\"allowSingleLine\":true}]",
		},
		{
			Code: `if (foo) { baz(); } else if (bar) {
  boom();
}`,
			Options: "[\"1tbs\",{\"allowSingleLine\":true}]",
		},
		{
			Code: `if (foo) { baz(); } else
if (bar) {
  boom();
}`,
			Options: "[\"1tbs\",{\"allowSingleLine\":true}]",
		},
		{
			Code: `try { somethingRisky(); } catch(e) {
  handleError();
}`,
			Options: "[\"1tbs\",{\"allowSingleLine\":true}]",
		},
		{
			Code: `if (tag === 1) fontstack.name = pbf.readString(); 
else if (tag === 2) fontstack.range = pbf.readString(); 
else if (tag === 3) {
 var glyph = pbf.readMessage(readGlyph, {});
 fontstack.glyphs[glyph.id] = glyph; 
}`,
			Options: "[\"1tbs\"]",
		},
		{
			Code: `if (tag === 1) fontstack.name = pbf.readString(); 
else if (tag === 2) fontstack.range = pbf.readString(); 
else if (tag === 3) {
 var glyph = pbf.readMessage(readGlyph, {});
 fontstack.glyphs[glyph.id] = glyph; 
}`,
			Options: "[\"stroustrup\"]",
		},
		{
			Code: `switch(x) 
{ 
 case 1: 
bar(); 
 }
 `,
			Options: "[\"allman\"]",
		},
		{
			Code:    `switch(x) {}`,
			Options: "[\"allman\",{\"allowSingleLine\":true}]",
		},
		{
			Code: `class Foo {
}`,
			Options: "[\"stroustrup\"]",
		},
		{
			Code: `(class {
})`,
			Options: "[\"stroustrup\"]",
		},
		{
			Code: `class Foo
{
}`,
			Options: "[\"allman\"]",
		},
		{
			Code: `(class
{
})`,
			Options: "[\"allman\"]",
		},
		{
			Code: `class
Foo
{
}`,
			Options: "[\"allman\"]",
		},
		{
			Code:    `class Foo {}`,
			Options: "[\"1tbs\",{\"allowSingleLine\":true}]",
		},
		{
			Code:    `class Foo {}`,
			Options: "[\"allman\",{\"allowSingleLine\":true}]",
		},
		{
			Code:    `(class {})`,
			Options: "[\"1tbs\",{\"allowSingleLine\":true}]",
		},
		{
			Code:    `(class {})`,
			Options: "[\"allman\",{\"allowSingleLine\":true}]",
		},
		{Code: `{}`},
		{Code: `
            if (foo) {

            }

            {

            }
        `},
		{Code: `
            switch (foo) {
                case bar:
                    baz();
                    {
                        qux();
                    }
            }
        `},
		{Code: `
            {
            }
        `},
		{Code: `
            {
                {
                }
            }
        `},
		{Code: `
          class Ball {
            throw() {}
            catch() {}
          }
        `},
		{Code: `
          ({
            and() {},
            finally() {}
          })
        `},
		{Code: `
          (class {
            or() {}
            else() {}
          })
        `},
		{Code: `
          if (foo) bar = function() {}
          else baz()
        `},
		{
			Code: `class C {
    static {
        foo;
    }
}`,
			Options:         "[\"1tbs\"]",
			LanguageOptions: "{\"ecmaVersion\":2022}",
		},
		{
			Code: `class C {
    static {}

    static {
    }
}`,
			Options:         "[\"1tbs\"]",
			LanguageOptions: "{\"ecmaVersion\":2022}",
		},
		{
			Code: `class C {
    static { foo; }
}`,
			Options:         "[\"1tbs\",{\"allowSingleLine\":true}]",
			LanguageOptions: "{\"ecmaVersion\":2022}",
		},
		{
			Code: `class C {
    static {
        foo;
    }
}`,
			Options:         "[\"stroustrup\"]",
			LanguageOptions: "{\"ecmaVersion\":2022}",
		},
		{
			Code: `class C {
    static {}

    static {
    }
}`,
			Options:         "[\"stroustrup\"]",
			LanguageOptions: "{\"ecmaVersion\":2022}",
		},
		{
			Code: `class C {
    static { foo; }
}`,
			Options:         "[\"stroustrup\",{\"allowSingleLine\":true}]",
			LanguageOptions: "{\"ecmaVersion\":2022}",
		},
		{
			Code: `class C
{
    static
    {
        foo;
    }
}`,
			Options:         "[\"allman\"]",
			LanguageOptions: "{\"ecmaVersion\":2022}",
		},
		{
			Code: `class C
{
    static
    {}
}`,
			Options:         "[\"allman\"]",
			LanguageOptions: "{\"ecmaVersion\":2022}",
		},
		{
			Code: `class C
{
    static {}

    static { foo; }

    static
    { foo; }
}`,
			Options:         "[\"allman\",{\"allowSingleLine\":true}]",
			LanguageOptions: "{\"ecmaVersion\":2022}",
		},
		{
			Code: `class C {
    static {
        {
            foo;
        }
    }
}`,
			Options:         "[\"1tbs\"]",
			LanguageOptions: "{\"ecmaVersion\":2022}",
		},
	}, []InvalidTestCase{
		{
			Code: `if (f) {
bar;
}
else
baz;`,
			Output: `if (f) {
bar;
} else
baz;`,
			Errors: []InvalidTestCaseError{
				{
					MessageId: "nextLineClose",
				},
			},
		},
		{
			Code: `var foo = () => { return; }`,
			Output: `var foo = () => {
 return; 
}`,
			LanguageOptions: "{\"ecmaVersion\":6}",
			Errors: []InvalidTestCaseError{
				{
					MessageId: "blockSameLine",
				},
				{
					MessageId: "singleLineClose",
				},
			},
		},
		{
			Code: `function foo() { return; }`,
			Output: `function foo() {
 return; 
}`,
			Errors: []InvalidTestCaseError{
				{
					MessageId: "blockSameLine",
				},
				{
					MessageId: "singleLineClose",
				},
			},
		},
		{
			Code: `function foo() 
 { 
 return; }`,
			Output: `function foo() { 
 return; 
}`,
			Errors: []InvalidTestCaseError{
				{
					MessageId: "nextLineOpen",
				},
				{
					MessageId: "singleLineClose",
				},
			},
		},
		{
			Code: `!function foo() 
 { 
 return; }`,
			Output: `!function foo() { 
 return; 
}`,
			Errors: []InvalidTestCaseError{
				{
					MessageId: "nextLineOpen",
				},
				{
					MessageId: "singleLineClose",
				},
			},
		},
		{
			Code: `if (foo) 
 { 
 bar(); }`,
			Output: `if (foo) { 
 bar(); 
}`,
			Errors: []InvalidTestCaseError{
				{
					MessageId: "nextLineOpen",
				},
				{
					MessageId: "singleLineClose",
				},
			},
		},
		{
			Code: `if (a) { 
b();
 } else 
 { c(); }`,
			Output: `if (a) { 
b();
 } else {
 c(); 
}`,
			Errors: []InvalidTestCaseError{
				{
					MessageId: "nextLineOpen",
				},
				{
					MessageId: "blockSameLine",
				},
				{
					MessageId: "singleLineClose",
				},
			},
		},
		{
			Code: `while (foo) 
 { 
 bar(); }`,
			Output: `while (foo) { 
 bar(); 
}`,
			Errors: []InvalidTestCaseError{
				{
					MessageId: "nextLineOpen",
				},
				{
					MessageId: "singleLineClose",
				},
			},
		},
		{
			Code: `for (;;) 
 { 
 bar(); }`,
			Output: `for (;;) { 
 bar(); 
}`,
			Errors: []InvalidTestCaseError{
				{
					MessageId: "nextLineOpen",
				},
				{
					MessageId: "singleLineClose",
				},
			},
		},
		{
			Code: `with (foo) 
 { 
 bar(); }`,
			Output: `with (foo) { 
 bar(); 
}`,
			Errors: []InvalidTestCaseError{
				{
					MessageId: "nextLineOpen",
				},
				{
					MessageId: "singleLineClose",
				},
			},
		},
		{
			Code: `switch (foo) 
 { 
 case "bar": break; }`,
			Output: `switch (foo) { 
 case "bar": break; 
}`,
			Errors: []InvalidTestCaseError{
				{
					MessageId: "nextLineOpen",
				},
				{
					MessageId: "singleLineClose",
				},
			},
		},
		{
			Code: `switch (foo) 
 { }`,
			Output: `switch (foo) { }`,
			Errors: []InvalidTestCaseError{
				{
					MessageId: "nextLineOpen",
				},
			},
		},
		{
			Code: `try 
 { 
 bar(); 
 } catch (e) {}`,
			Output: `try { 
 bar(); 
 } catch (e) {}`,
			Errors: []InvalidTestCaseError{
				{
					MessageId: "nextLineOpen",
				},
			},
		},
		{
			Code: `try { 
 bar(); 
 } catch (e) 
 {}`,
			Output: `try { 
 bar(); 
 } catch (e) {}`,
			Errors: []InvalidTestCaseError{
				{
					MessageId: "nextLineOpen",
				},
			},
		},
		{
			Code: `do 
 { 
 bar(); 
} while (true)`,
			Output: `do { 
 bar(); 
} while (true)`,
			Errors: []InvalidTestCaseError{
				{
					MessageId: "nextLineOpen",
				},
			},
		},
		{
			Code: `for (foo in bar) 
 { 
 baz(); 
 }`,
			Output: `for (foo in bar) { 
 baz(); 
 }`,
			Errors: []InvalidTestCaseError{
				{
					MessageId: "nextLineOpen",
				},
			},
		},
		{
			Code: `for (foo of bar) 
 { 
 baz(); 
 }`,
			Output: `for (foo of bar) { 
 baz(); 
 }`,
			LanguageOptions: "{\"ecmaVersion\":6}",
			Errors: []InvalidTestCaseError{
				{
					MessageId: "nextLineOpen",
				},
			},
		},
		{
			Code: `try { 
 bar(); 
 }
catch (e) {
}`,
			Output: `try { 
 bar(); 
 } catch (e) {
}`,
			Errors: []InvalidTestCaseError{
				{
					MessageId: "nextLineClose",
				},
			},
		},
		{
			Code: `try { 
 bar(); 
 } catch (e) {
}
 finally {
}`,
			Output: `try { 
 bar(); 
 } catch (e) {
} finally {
}`,
			Errors: []InvalidTestCaseError{
				{
					MessageId: "nextLineClose",
				},
			},
		},
		{
			Code: `if (a) { 
b();
 } 
 else { 
c();
 }`,
			Output: `if (a) { 
b();
 } else { 
c();
 }`,
			Errors: []InvalidTestCaseError{
				{
					MessageId: "nextLineClose",
				},
			},
		},
		{
			Code: `try { 
 bar(); 
 }
catch (e) {
} finally {
}`,
			Output: `try { 
 bar(); 
 }
catch (e) {
}
 finally {
}`,
			Options: "[\"stroustrup\"]",
			Errors: []InvalidTestCaseError{
				{
					MessageId: "sameLineClose",
				},
			},
		},
		{
			Code: `try { 
 bar(); 
 } catch (e) {
}
 finally {
}`,
			Output: `try { 
 bar(); 
 }
 catch (e) {
}
 finally {
}`,
			Options: "[\"stroustrup\"]",
			Errors: []InvalidTestCaseError{
				{
					MessageId: "sameLineClose",
				},
			},
		},
		{
			Code: `if (a) { 
b();
 } else { 
c();
 }`,
			Output: `if (a) { 
b();
 }
 else { 
c();
 }`,
			Options: "[\"stroustrup\"]",
			Errors: []InvalidTestCaseError{
				{
					MessageId: "sameLineClose",
				},
			},
		},
		{
			Code: `if (foo) {
baz();
} else if (bar) {
baz();
}
else {
qux();
}`,
			Output: `if (foo) {
baz();
}
 else if (bar) {
baz();
}
else {
qux();
}`,
			Options: "[\"stroustrup\"]",
			Errors: []InvalidTestCaseError{
				{
					MessageId: "sameLineClose",
				},
			},
		},
		{
			Code: `if (foo) {
poop();
} 
else if (bar) {
baz();
} else if (thing) {
boom();
}
else {
qux();
}`,
			Output: `if (foo) {
poop();
} 
else if (bar) {
baz();
}
 else if (thing) {
boom();
}
else {
qux();
}`,
			Options: "[\"stroustrup\"]",
			Errors: []InvalidTestCaseError{
				{
					MessageId: "sameLineClose",
				},
			},
		},
		{
			Code: `try { 
 bar(); 
 }
 catch (e) {
}
 finally {
}`,
			Output: `try 
{ 
 bar(); 
 }
 catch (e) 
{
}
 finally 
{
}`,
			Options: "[\"allman\"]",
			Errors: []InvalidTestCaseError{
				{
					MessageId: "sameLineOpen",
					Line:      1,
				},
				{
					MessageId: "sameLineOpen",
					Line:      4,
				},
				{
					MessageId: "sameLineOpen",
					Line:      6,
				},
			},
		},
		{
			Code: `switch(x) { case 1: 
bar(); }
 `,
			Output: `switch(x) 
{
 case 1: 
bar(); 
}
 `,
			Options: "[\"allman\"]",
			Errors: []InvalidTestCaseError{
				{
					MessageId: "sameLineOpen",
					Line:      1,
				},
				{
					MessageId: "blockSameLine",
					Line:      1,
				},
				{
					MessageId: "singleLineClose",
					Line:      2,
				},
			},
		},
		{
			Code: `if (a) { 
b();
 } else { 
c();
 }`,
			Output: `if (a) 
{ 
b();
 }
 else 
{ 
c();
 }`,
			Options: "[\"allman\"]",
			Errors: []InvalidTestCaseError{
				{
					MessageId: "sameLineOpen",
				},
				{
					MessageId: "sameLineClose",
				},
				{
					MessageId: "sameLineOpen",
				},
			},
		},
		{
			Code: `if (foo) {
baz();
} else if (bar) {
baz();
}
else {
qux();
}`,
			Output: `if (foo) 
{
baz();
}
 else if (bar) 
{
baz();
}
else 
{
qux();
}`,
			Options: "[\"allman\"]",
			Errors: []InvalidTestCaseError{
				{
					MessageId: "sameLineOpen",
				},
				{
					MessageId: "sameLineClose",
				},
				{
					MessageId: "sameLineOpen",
				},
				{
					MessageId: "sameLineOpen",
				},
			},
		},
		{
			Code: `if (foo)
{ poop();
} 
else if (bar) {
baz();
} else if (thing) {
boom();
}
else {
qux();
}`,
			Output: `if (foo)
{
 poop();
} 
else if (bar) 
{
baz();
}
 else if (thing) 
{
boom();
}
else 
{
qux();
}`,
			Options: "[\"allman\"]",
			Errors: []InvalidTestCaseError{
				{
					MessageId: "blockSameLine",
				},
				{
					MessageId: "sameLineOpen",
				},
				{
					MessageId: "sameLineClose",
				},
				{
					MessageId: "sameLineOpen",
				},
				{
					MessageId: "sameLineOpen",
				},
			},
		},
		{
			Code: `if (foo)
{
  bar(); }`,
			Output: `if (foo)
{
  bar(); 
}`,
			Options: "[\"allman\"]",
			Errors: []InvalidTestCaseError{
				{
					MessageId: "singleLineClose",
				},
			},
		},
		{
			Code: `try
{
  somethingRisky();
} catch (e)
{
  handleError()
}`,
			Output: `try
{
  somethingRisky();
}
 catch (e)
{
  handleError()
}`,
			Options: "[\"allman\"]",
			Errors: []InvalidTestCaseError{
				{
					MessageId: "sameLineClose",
				},
			},
		},
		{
			Code: `function foo() { return; 
}`,
			Output: `function foo() {
 return; 
}`,
			Options: "[\"1tbs\",{\"allowSingleLine\":true}]",
			Errors: []InvalidTestCaseError{
				{
					MessageId: "blockSameLine",
				},
			},
		},
		{
			Code: `function foo() { a(); b(); return; 
}`,
			Output: `function foo() {
 a(); b(); return; 
}`,
			Options: "[\"1tbs\",{\"allowSingleLine\":true}]",
			Errors: []InvalidTestCaseError{
				{
					MessageId: "blockSameLine",
				},
			},
		},
		{
			Code: `function foo() { 
 return; }`,
			Output: `function foo() { 
 return; 
}`,
			Options: "[\"1tbs\",{\"allowSingleLine\":true}]",
			Errors: []InvalidTestCaseError{
				{
					MessageId: "singleLineClose",
				},
			},
		},
		{
			Code: `function foo() {
a();
b();
return; }`,
			Output: `function foo() {
a();
b();
return; 
}`,
			Options: "[\"1tbs\",{\"allowSingleLine\":true}]",
			Errors: []InvalidTestCaseError{
				{
					MessageId: "singleLineClose",
				},
			},
		},
		{
			Code: `!function foo() { 
 return; }`,
			Output: `!function foo() { 
 return; 
}`,
			Options: "[\"1tbs\",{\"allowSingleLine\":true}]",
			Errors: []InvalidTestCaseError{
				{
					MessageId: "singleLineClose",
				},
			},
		},
		{
			Code: `if (a) { b();
 } else { c(); }`,
			Output: `if (a) {
 b();
 } else { c(); }`,
			Options: "[\"1tbs\",{\"allowSingleLine\":true}]",
			Errors: []InvalidTestCaseError{
				{
					MessageId: "blockSameLine",
				},
			},
		},
		{
			Code: `if (a) { b(); }
else { c(); }`,
			Output:  `if (a) { b(); } else { c(); }`,
			Options: "[\"1tbs\",{\"allowSingleLine\":true}]",
			Errors: []InvalidTestCaseError{
				{
					MessageId: "nextLineClose",
				},
			},
		},
		{
			Code: `while (foo) { 
 bar(); }`,
			Output: `while (foo) { 
 bar(); 
}`,
			Options: "[\"1tbs\",{\"allowSingleLine\":true}]",
			Errors: []InvalidTestCaseError{
				{
					MessageId: "singleLineClose",
				},
			},
		},
		{
			Code: `for (;;) { bar(); 
 }`,
			Output: `for (;;) {
 bar(); 
 }`,
			Options: "[\"1tbs\",{\"allowSingleLine\":true}]",
			Errors: []InvalidTestCaseError{
				{
					MessageId: "blockSameLine",
				},
			},
		},
		{
			Code: `with (foo) { bar(); 
 }`,
			Output: `with (foo) {
 bar(); 
 }`,
			Options: "[\"1tbs\",{\"allowSingleLine\":true}]",
			Errors: []InvalidTestCaseError{
				{
					MessageId: "blockSameLine",
				},
			},
		},
		{
			Code: `switch (foo) 
 { 
 case "bar": break; }`,
			Output: `switch (foo) { 
 case "bar": break; 
}`,
			Options: "[\"1tbs\",{\"allowSingleLine\":true}]",
			Errors: []InvalidTestCaseError{
				{
					MessageId: "nextLineOpen",
				},
				{
					MessageId: "singleLineClose",
				},
			},
		},
		{
			Code: `switch (foo) 
 { }`,
			Output:  `switch (foo) { }`,
			Options: "[\"1tbs\",{\"allowSingleLine\":true}]",
			Errors: []InvalidTestCaseError{
				{
					MessageId: "nextLineOpen",
				},
			},
		},
		{
			Code: `try {  bar(); }
catch (e) { baz();  }`,
			Output:  `try {  bar(); } catch (e) { baz();  }`,
			Options: "[\"1tbs\",{\"allowSingleLine\":true}]",
			Errors: []InvalidTestCaseError{
				{
					MessageId: "nextLineClose",
				},
			},
		},
		{
			Code: `try 
 { 
 bar(); 
 } catch (e) {}`,
			Output: `try { 
 bar(); 
 } catch (e) {}`,
			Options: "[\"1tbs\",{\"allowSingleLine\":true}]",
			Errors: []InvalidTestCaseError{
				{
					MessageId: "nextLineOpen",
				},
			},
		},
		{
			Code: `try { 
 bar(); 
 } catch (e) 
 {}`,
			Output: `try { 
 bar(); 
 } catch (e) {}`,
			Options: "[\"1tbs\",{\"allowSingleLine\":true}]",
			Errors: []InvalidTestCaseError{
				{
					MessageId: "nextLineOpen",
				},
			},
		},
		{
			Code: `do 
 { 
 bar(); 
} while (true)`,
			Output: `do { 
 bar(); 
} while (true)`,
			Options: "[\"1tbs\",{\"allowSingleLine\":true}]",
			Errors: []InvalidTestCaseError{
				{
					MessageId: "nextLineOpen",
				},
			},
		},
		{
			Code: `for (foo in bar) 
 { 
 baz(); 
 }`,
			Output: `for (foo in bar) { 
 baz(); 
 }`,
			Options: "[\"1tbs\",{\"allowSingleLine\":true}]",
			Errors: []InvalidTestCaseError{
				{
					MessageId: "nextLineOpen",
				},
			},
		},
		{
			Code: `try { 
 bar(); 
 }
catch (e) {
}`,
			Output: `try { 
 bar(); 
 } catch (e) {
}`,
			Options: "[\"1tbs\",{\"allowSingleLine\":true}]",
			Errors: []InvalidTestCaseError{
				{
					MessageId: "nextLineClose",
				},
			},
		},
		{
			Code: `try { 
 bar(); 
 } catch (e) {
}
 finally {
}`,
			Output: `try { 
 bar(); 
 } catch (e) {
} finally {
}`,
			Options: "[\"1tbs\",{\"allowSingleLine\":true}]",
			Errors: []InvalidTestCaseError{
				{
					MessageId: "nextLineClose",
				},
			},
		},
		{
			Code: `if (a) { 
b();
 } 
 else { 
c();
 }`,
			Output: `if (a) { 
b();
 } else { 
c();
 }`,
			Options: "[\"1tbs\",{\"allowSingleLine\":true}]",
			Errors: []InvalidTestCaseError{
				{
					MessageId: "nextLineClose",
				},
			},
		},
		{
			Code: `try { 
 bar(); 
 }
catch (e) {
} finally {
}`,
			Output: `try { 
 bar(); 
 }
catch (e) {
}
 finally {
}`,
			Options: "[\"stroustrup\",{\"allowSingleLine\":true}]",
			Errors: []InvalidTestCaseError{
				{
					MessageId: "sameLineClose",
				},
			},
		},
		{
			Code: `try { 
 bar(); 
 } catch (e) {
}
 finally {
}`,
			Output: `try { 
 bar(); 
 }
 catch (e) {
}
 finally {
}`,
			Options: "[\"stroustrup\",{\"allowSingleLine\":true}]",
			Errors: []InvalidTestCaseError{
				{
					MessageId: "sameLineClose",
				},
			},
		},
		{
			Code: `if (a) { 
b();
 } else { 
c();
 }`,
			Output: `if (a) { 
b();
 }
 else { 
c();
 }`,
			Options: "[\"stroustrup\",{\"allowSingleLine\":true}]",
			Errors: []InvalidTestCaseError{
				{
					MessageId: "sameLineClose",
				},
			},
		},
		{
			Code: `if (foo)
{ poop();
} 
else if (bar) {
baz();
} else if (thing) {
boom();
}
else {
qux();
}`,
			Output: `if (foo)
{
 poop();
} 
else if (bar) 
{
baz();
}
 else if (thing) 
{
boom();
}
else 
{
qux();
}`,
			Options: "[\"allman\",{\"allowSingleLine\":true}]",
			Errors: []InvalidTestCaseError{
				{
					MessageId: "blockSameLine",
				},
				{
					MessageId: "sameLineOpen",
				},
				{
					MessageId: "sameLineClose",
				},
				{
					MessageId: "sameLineOpen",
				},
				{
					MessageId: "sameLineOpen",
				},
			},
		},
		{
			Code: `if (foo) // comment 
{
bar();
}`,
			Errors: []InvalidTestCaseError{
				{
					MessageId: "nextLineOpen",
				},
			},
		},
		{
			Code: `if (foo) {
 bar
.baz }`,
			Output: `if (foo) {
 bar
.baz 
}`,
			Errors: []InvalidTestCaseError{
				{
					MessageId: "singleLineClose",
				},
			},
		},
		{
			Code: `if (foo)
{
 bar
.baz }`,
			Output: `if (foo)
{
 bar
.baz 
}`,
			Options: "[\"allman\"]",
			Errors: []InvalidTestCaseError{
				{
					MessageId: "singleLineClose",
				},
			},
		},
		{
			Code: `if (foo) { bar
.baz }`,
			Output: `if (foo) {
 bar
.baz 
}`,
			Options: "[\"1tbs\",{\"allowSingleLine\":true}]",
			Errors: []InvalidTestCaseError{
				{
					MessageId: "blockSameLine",
				},
				{
					MessageId: "singleLineClose",
				},
			},
		},
		{
			Code: `if (foo) { bar
.baz }`,
			Output: `if (foo) 
{
 bar
.baz 
}`,
			Options: "[\"allman\",{\"allowSingleLine\":true}]",
			Errors: []InvalidTestCaseError{
				{
					MessageId: "sameLineOpen",
				},
				{
					MessageId: "blockSameLine",
				},
				{
					MessageId: "singleLineClose",
				},
			},
		},
		{
			Code: `switch (x) {
 case 1: foo() }`,
			Output: `switch (x) {
 case 1: foo() 
}`,
			Options: "[\"1tbs\",{\"allowSingleLine\":true}]",
			Errors: []InvalidTestCaseError{
				{
					MessageId: "singleLineClose",
				},
			},
		},
		{
			Code: `class Foo
{
}`,
			Output: `class Foo {
}`,
			Errors: []InvalidTestCaseError{
				{
					MessageId: "nextLineOpen",
				},
			},
		},
		{
			Code: `(class
{
})`,
			Output: `(class {
})`,
			Errors: []InvalidTestCaseError{
				{
					MessageId: "nextLineOpen",
				},
			},
		},
		{
			Code: `class Foo{
}`,
			Output: `class Foo
{
}`,
			Options: "[\"allman\"]",
			Errors: []InvalidTestCaseError{
				{
					MessageId: "sameLineOpen",
				},
			},
		},
		{
			Code: `(class {
})`,
			Output: `(class 
{
})`,
			Options: "[\"allman\"]",
			Errors: []InvalidTestCaseError{
				{
					MessageId: "sameLineOpen",
				},
			},
		},
		{
			Code: `class Foo {
bar() {
}}`,
			Output: `class Foo {
bar() {
}
}`,
			Errors: []InvalidTestCaseError{
				{
					MessageId: "singleLineClose",
				},
			},
		},
		{
			Code: `(class Foo {
bar() {
}})`,
			Output: `(class Foo {
bar() {
}
})`,
			Errors: []InvalidTestCaseError{
				{
					MessageId: "singleLineClose",
				},
			},
		},
		{
			Code: `class
Foo{}`,
			Output: `class
Foo
{}`,
			Options: "[\"allman\"]",
			Errors: []InvalidTestCaseError{
				{
					MessageId: "sameLineOpen",
				},
			},
		},
		{
			Code: `
                if (foo)
                {
                    bar
                }
                else {
                    baz
                }
            `,
			Output: `
                if (foo) {
                    bar
                } else {
                    baz
                }
            `,
			Errors: []InvalidTestCaseError{
				{
					MessageId: "nextLineOpen",
				},
				{
					MessageId: "nextLineClose",
				},
			},
		},
		{
			Code: `class C {
    static
    {
        foo;
    }
}`,
			Output: `class C {
    static {
        foo;
    }
}`,
			Options:         "[\"1tbs\"]",
			LanguageOptions: "{\"ecmaVersion\":2022}",
			Errors: []InvalidTestCaseError{
				{
					MessageId: "nextLineOpen",
				},
			},
		},
		{
			Code: `class C {
    static {foo;
    }
}`,
			Output: `class C {
    static {
foo;
    }
}`,
			Options:         "[\"1tbs\"]",
			LanguageOptions: "{\"ecmaVersion\":2022}",
			Errors: []InvalidTestCaseError{
				{
					MessageId: "blockSameLine",
				},
			},
		},
		{
			Code: `class C {
    static {
        foo;}
}`,
			Output: `class C {
    static {
        foo;
}
}`,
			Options:         "[\"1tbs\"]",
			LanguageOptions: "{\"ecmaVersion\":2022}",
			Errors: []InvalidTestCaseError{
				{
					MessageId: "singleLineClose",
				},
			},
		},
		{
			Code: `class C {
    static
    {foo;}
}`,
			Output: `class C {
    static {
foo;
}
}`,
			Options:         "[\"1tbs\"]",
			LanguageOptions: "{\"ecmaVersion\":2022}",
			Errors: []InvalidTestCaseError{
				{
					MessageId: "nextLineOpen",
				},
				{
					MessageId: "blockSameLine",
				},
				{
					MessageId: "singleLineClose",
				},
			},
		},
		{
			Code: `class C {
    static
    {}
}`,
			Output: `class C {
    static {}
}`,
			Options:         "[\"1tbs\"]",
			LanguageOptions: "{\"ecmaVersion\":2022}",
			Errors: []InvalidTestCaseError{
				{
					MessageId: "nextLineOpen",
				},
			},
		},
		{
			Code: `class C {
    static
    {
        foo;
    }
}`,
			Output: `class C {
    static {
        foo;
    }
}`,
			Options:         "[\"stroustrup\"]",
			LanguageOptions: "{\"ecmaVersion\":2022}",
			Errors: []InvalidTestCaseError{
				{
					MessageId: "nextLineOpen",
				},
			},
		},
		{
			Code: `class C {
    static {foo;
    }
}`,
			Output: `class C {
    static {
foo;
    }
}`,
			Options:         "[\"stroustrup\"]",
			LanguageOptions: "{\"ecmaVersion\":2022}",
			Errors: []InvalidTestCaseError{
				{
					MessageId: "blockSameLine",
				},
			},
		},
		{
			Code: `class C {
    static {
        foo;}
}`,
			Output: `class C {
    static {
        foo;
}
}`,
			Options:         "[\"stroustrup\"]",
			LanguageOptions: "{\"ecmaVersion\":2022}",
			Errors: []InvalidTestCaseError{
				{
					MessageId: "singleLineClose",
				},
			},
		},
		{
			Code: `class C {
    static
    {foo;}
}`,
			Output: `class C {
    static {
foo;
}
}`,
			Options:         "[\"stroustrup\"]",
			LanguageOptions: "{\"ecmaVersion\":2022}",
			Errors: []InvalidTestCaseError{
				{
					MessageId: "nextLineOpen",
				},
				{
					MessageId: "blockSameLine",
				},
				{
					MessageId: "singleLineClose",
				},
			},
		},
		{
			Code: `class C {
    static
    {}
}`,
			Output: `class C {
    static {}
}`,
			Options:         "[\"stroustrup\"]",
			LanguageOptions: "{\"ecmaVersion\":2022}",
			Errors: []InvalidTestCaseError{
				{
					MessageId: "nextLineOpen",
				},
			},
		},
		{
			Code: `class C
{
    static{
        foo;
    }
}`,
			Output: `class C
{
    static
{
        foo;
    }
}`,
			Options:         "[\"allman\"]",
			LanguageOptions: "{\"ecmaVersion\":2022}",
			Errors: []InvalidTestCaseError{
				{
					MessageId: "sameLineOpen",
				},
			},
		},
		{
			Code: `class C
{
    static
    {foo;
    }
}`,
			Output: `class C
{
    static
    {
foo;
    }
}`,
			Options:         "[\"allman\"]",
			LanguageOptions: "{\"ecmaVersion\":2022}",
			Errors: []InvalidTestCaseError{
				{
					MessageId: "blockSameLine",
				},
			},
		},
		{
			Code: `class C
{
    static
    {
        foo;}
}`,
			Output: `class C
{
    static
    {
        foo;
}
}`,
			Options:         "[\"allman\"]",
			LanguageOptions: "{\"ecmaVersion\":2022}",
			Errors: []InvalidTestCaseError{
				{
					MessageId: "singleLineClose",
				},
			},
		},
		{
			Code: `class C
{
    static{foo;}
}`,
			Output: `class C
{
    static
{
foo;
}
}`,
			Options:         "[\"allman\"]",
			LanguageOptions: "{\"ecmaVersion\":2022}",
			Errors: []InvalidTestCaseError{
				{
					MessageId: "sameLineOpen",
				},
				{
					MessageId: "blockSameLine",
				},
				{
					MessageId: "singleLineClose",
				},
			},
		},
		{
			Code: `class C
{
    static{}
}`,
			Output: `class C
{
    static
{}
}`,
			Options:         "[\"allman\"]",
			LanguageOptions: "{\"ecmaVersion\":2022}",
			Errors: []InvalidTestCaseError{
				{
					MessageId: "sameLineOpen",
				},
			},
		},
	})
}
